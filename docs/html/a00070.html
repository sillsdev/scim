<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>scim: scim::Pointer&lt; T &gt; Class Template Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.0 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li id="current"><a href="classes.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="classes.html"><span>Alphabetical&nbsp;List</span></a></li>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul></div>
<div class="nav">
<a class="el" href="a00157.html">scim</a>::<a class="el" href="a00070.html">Pointer</a></div>
<h1>scim::Pointer&lt; T &gt; Class Template Reference<br>
<small>
[<a class="el" href="a00158.html">Accessories</a>,&nbsp;<a class="el" href="a00158.html">Accessories</a>]</small>
</h1><!-- doxytag: class="scim::Pointer" -->Smart pointer template class.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;scim_pointer.h&gt;</code>
<p>
Collaboration diagram for scim::Pointer&lt; T &gt;:<p><center><img src="a00422.png" border="0" usemap="#a00423" alt="Collaboration graph"></center>
<center><font size="2">[<a target="top" href="graph_legend.html">legend</a>]</font></center><a href="a00424.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Constructors</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00070.html#e7d7ac8a0cf758a4993938cc44919e8b">Pointer</a> (T *object=0)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00070.html#38ae912ff77dc4b21925859e4a0f6d96">Pointer</a> (<a class="el" href="a00070.html">Pointer</a> &amp;src)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T1&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00070.html#bbc135b7483f940989b36ed114568bdd">Pointer</a> (const <a class="el" href="a00070.html">Pointer</a>&lt; T1 &gt; &amp;src)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00070.html#30b54c613f50f81db9697d3f8bf5c7e8">~Pointer</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="a00070.html">Pointer</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00070.html#5b71a68f52acbcc50affda171fca806d">operator=</a> (T *object)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="a00070.html">Pointer</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00070.html#6deef1b0d31a5474d8fa1ab7bb02b47a">operator=</a> (const <a class="el" href="a00070.html">Pointer</a> &amp;src)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T1&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="a00070.html">Pointer</a> &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00070.html#d41f46cadd8dd41c9dd8629fe6cd0baa">operator=</a> (const <a class="el" href="a00070.html">Pointer</a>&lt; T1 &gt; &amp;src)</td></tr>

<tr><td colspan="2"><br><h2>Friends</h2></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T1, typename T2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00070.html#681b62e04f3b869c899a18089eb39cc3">operator==</a> (const <a class="el" href="a00070.html">Pointer</a>&lt; T1 &gt; &amp;t1, const <a class="el" href="a00070.html">Pointer</a>&lt; T2 &gt; &amp;t2)</td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;typename T&gt;<br>
 class scim::Pointer&lt; T &gt;</h3>

Smart pointer template class. 
<p>
<a class="el" href="a00070.html">Pointer</a> is a standard auto_ptr-like smart pointer for managing heap allocated reference counted objects. T must be a class derived from <a class="el" href="a00072.html">scim::ReferencedObject</a>. 
<p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="e7d7ac8a0cf758a4993938cc44919e8b"></a><!-- doxytag: member="scim::Pointer::Pointer" ref="e7d7ac8a0cf758a4993938cc44919e8b" args="(T *object=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00070.html">scim::Pointer</a>&lt; T &gt;::<a class="el" href="a00070.html">Pointer</a>           </td>
          <td>(</td>
          <td class="paramtype">T *&nbsp;</td>
          <td class="paramname"> <em>object</em> = <code>0</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Construct a new smart pointer. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>object</em>&nbsp;</td><td>- a pointer to an object allocated on the heap.</td></tr>
  </table>
</dl>
<br>
Initialize a new <a class="el" href="a00070.html">Pointer</a> with any dumb pointer. 
</div>
</div><p>
<a class="anchor" name="38ae912ff77dc4b21925859e4a0f6d96"></a><!-- doxytag: member="scim::Pointer::Pointer" ref="38ae912ff77dc4b21925859e4a0f6d96" args="(Pointer &amp;src)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00070.html">scim::Pointer</a>&lt; T &gt;::<a class="el" href="a00070.html">Pointer</a>           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00070.html">Pointer</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>src</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copy constructor. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>- a reference to a smart pointer.</td></tr>
  </table>
</dl>
<br>
Initialize a new <a class="el" href="a00070.html">Pointer</a> with any compatible <a class="el" href="a00070.html">Pointer</a>. 
</div>
</div><p>
<a class="anchor" name="bbc135b7483f940989b36ed114568bdd"></a><!-- doxytag: member="scim::Pointer::Pointer" ref="bbc135b7483f940989b36ed114568bdd" args="(const Pointer&lt; T1 &gt; &amp;src)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename T1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00070.html">scim::Pointer</a>&lt; T &gt;::<a class="el" href="a00070.html">Pointer</a>           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00070.html">Pointer</a>&lt; T1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>src</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copy constructor. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>- a <a class="el" href="a00070.html">Pointer</a> to type T1 where T1 is derived from T.</td></tr>
  </table>
</dl>
<br>
Initialize a new <a class="el" href="a00070.html">Pointer</a> of type T from a <a class="el" href="a00070.html">Pointer</a> of type T1, only if T1 is derived from T. 
</div>
</div><p>
<a class="anchor" name="30b54c613f50f81db9697d3f8bf5c7e8"></a><!-- doxytag: member="scim::Pointer::~Pointer" ref="30b54c613f50f81db9697d3f8bf5c7e8" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00070.html">scim::Pointer</a>&lt; T &gt;::~<a class="el" href="a00070.html">Pointer</a>           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Destructor. Decreases the object reference count. 
</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="5b71a68f52acbcc50affda171fca806d"></a><!-- doxytag: member="scim::Pointer::operator=" ref="5b71a68f52acbcc50affda171fca806d" args="(T *object)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00070.html">Pointer</a>&amp; <a class="el" href="a00070.html">scim::Pointer</a>&lt; T &gt;::operator=           </td>
          <td>(</td>
          <td class="paramtype">T *&nbsp;</td>
          <td class="paramname"> <em>object</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Assignment operator. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>object</em>&nbsp;</td><td>- a pointer to an object allocated on the heap.</td></tr>
  </table>
</dl>
<br>
Releases the current dumb pointer, if any and assigns <em>object</em> to this <a class="el" href="a00070.html">Pointer</a>, incrementing its reference count. 
</div>
</div><p>
<a class="anchor" name="6deef1b0d31a5474d8fa1ab7bb02b47a"></a><!-- doxytag: member="scim::Pointer::operator=" ref="6deef1b0d31a5474d8fa1ab7bb02b47a" args="(const Pointer &amp;src)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00070.html">Pointer</a>&amp; <a class="el" href="a00070.html">scim::Pointer</a>&lt; T &gt;::operator=           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00070.html">Pointer</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>src</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Assignment operator. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>- a reference to a smart pointer.</td></tr>
  </table>
</dl>
<br>
Releases the current dumb pointer, if any and assigns the dumb pointer managed by <em>src</em> to this <a class="el" href="a00070.html">Pointer</a>, incrementing its reference count. 
</div>
</div><p>
<a class="anchor" name="d41f46cadd8dd41c9dd8629fe6cd0baa"></a><!-- doxytag: member="scim::Pointer::operator=" ref="d41f46cadd8dd41c9dd8629fe6cd0baa" args="(const Pointer&lt; T1 &gt; &amp;src)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename T1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00070.html">Pointer</a>&amp; <a class="el" href="a00070.html">scim::Pointer</a>&lt; T &gt;::operator=           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00070.html">Pointer</a>&lt; T1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>src</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Assignment operator. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>- a <a class="el" href="a00070.html">Pointer</a> to type T1 where T1 is derived from T.</td></tr>
  </table>
</dl>
<br>
Releases the current dumb pointer, if any and assigns the dumb pointer of type T1 managed by <em>src</em> to this <a class="el" href="a00070.html">Pointer</a> as a dumb pointer of type T, only if T1 is derived from T. The reference count is incremented. 
</div>
</div><p>
<a class="anchor" name="735b87734d42dd9f13f56b97a46e3f42"></a><!-- doxytag: member="scim::Pointer::operator *" ref="735b87734d42dd9f13f56b97a46e3f42" args="() const" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="a00070.html">scim::Pointer</a>&lt; T &gt;::operator *           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Dereference operator. <dl class="return" compact><dt><b>Returns:</b></dt><dd>a reference to the object pointed to by the dumb pointer. </dd></dl>

</div>
</div><p>
<a class="anchor" name="f4f34da4b45ca30e01325b700caf09fd"></a><!-- doxytag: member="scim::Pointer::operator-&gt;" ref="f4f34da4b45ca30e01325b700caf09fd" args="() const" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="a00070.html">scim::Pointer</a>&lt; T &gt;::operator-&gt;           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Member selection operator. <dl class="return" compact><dt><b>Returns:</b></dt><dd>the dumb pointer. </dd></dl>

</div>
</div><p>
<a class="anchor" name="6f3ff0dc83718c2298201227de6617a3"></a><!-- doxytag: member="scim::Pointer::operator T *" ref="6f3ff0dc83718c2298201227de6617a3" args="() const" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00070.html">scim::Pointer</a>&lt; T &gt;::operator T *           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Conversion operator. Converts a <a class="el" href="a00070.html">Pointer</a> into its dumb pointer: the C pointer it manages. Normally it is considered pretty evil to mix smart and regular pointers. In scim you can safely if you just follow the reference counting rules for each of them. You can never call delete on <a class="el" href="a00070.html">Pointer</a> either because you don't call delete on scim objects; you call unref(). 
</div>
</div><p>
<a class="anchor" name="6c9b1b9ec0b5095c80f01b302d7ae8fc"></a><!-- doxytag: member="scim::Pointer::get" ref="6c9b1b9ec0b5095c80f01b302d7ae8fc" args="() const" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="a00070.html">scim::Pointer</a>&lt; T &gt;::get           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the dumb pointer; the regular C pointer managed by the <a class="el" href="a00070.html">Pointer</a>. <dl class="return" compact><dt><b>Returns:</b></dt><dd>the dumb pointer. </dd></dl>

</div>
</div><p>
<a class="anchor" name="66c25e7cafa450953b2be771e54e9631"></a><!-- doxytag: member="scim::Pointer::null" ref="66c25e7cafa450953b2be771e54e9631" args="() const" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00070.html">scim::Pointer</a>&lt; T &gt;::null           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns true if the <a class="el" href="a00070.html">Pointer</a> has no dumb pointer. 
<p>

</div>
</div><p>
<a class="anchor" name="ad78f476defa6c49b73f2e273309038c"></a><!-- doxytag: member="scim::Pointer::release" ref="ad78f476defa6c49b73f2e273309038c" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="a00070.html">scim::Pointer</a>&lt; T &gt;::release           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Releases the dumb pointer. <dl class="return" compact><dt><b>Returns:</b></dt><dd>the regular C pointer previously managed by the <a class="el" href="a00070.html">Pointer</a>.</dd></dl>
<br>
Before releasing the dumb pointer its reference count is incremented to prevent it being destroyed. You must call unref() on the pointer to prevent a memory leak. 
</div>
</div><p>
<a class="anchor" name="e3a6ef3a74cece3307a949a9d8c8b59d"></a><!-- doxytag: member="scim::Pointer::reset" ref="e3a6ef3a74cece3307a949a9d8c8b59d" args="(T *object=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00070.html">scim::Pointer</a>&lt; T &gt;::reset           </td>
          <td>(</td>
          <td class="paramtype">T *&nbsp;</td>
          <td class="paramname"> <em>object</em> = <code>0</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets a new dumb pointer for the <a class="el" href="a00070.html">Pointer</a> to manage. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>object</em>&nbsp;</td><td>- the new dumb pointer.</td></tr>
  </table>
</dl>
<br>
Releases the current dumb pointer, if any, and assigns <em>object</em> to the <a class="el" href="a00070.html">Pointer</a>, incrementing its reference count. 
</div>
</div><p>
<a class="anchor" name="735b87734d42dd9f13f56b97a46e3f42"></a><!-- doxytag: member="scim::Pointer::operator *" ref="735b87734d42dd9f13f56b97a46e3f42" args="() const" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="a00070.html">scim::Pointer</a>&lt; T &gt;::operator *           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Dereference operator. <dl class="return" compact><dt><b>Returns:</b></dt><dd>a reference to the object pointed to by the dumb pointer. </dd></dl>

</div>
</div><p>
<a class="anchor" name="f4f34da4b45ca30e01325b700caf09fd"></a><!-- doxytag: member="scim::Pointer::operator-&gt;" ref="f4f34da4b45ca30e01325b700caf09fd" args="() const" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="a00070.html">scim::Pointer</a>&lt; T &gt;::operator-&gt;           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Member selection operator. <dl class="return" compact><dt><b>Returns:</b></dt><dd>the dumb pointer. </dd></dl>

</div>
</div><p>
<a class="anchor" name="6f3ff0dc83718c2298201227de6617a3"></a><!-- doxytag: member="scim::Pointer::operator T *" ref="6f3ff0dc83718c2298201227de6617a3" args="() const" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00070.html">scim::Pointer</a>&lt; T &gt;::operator T *           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Conversion operator. Converts a <a class="el" href="a00070.html">Pointer</a> into its dumb pointer: the C pointer it manages. Normally it is considered pretty evil to mix smart and regular pointers. In scim you can safely if you just follow the reference counting rules for each of them. You can never call delete on <a class="el" href="a00070.html">Pointer</a> either because you don't call delete on scim objects; you call unref(). 
</div>
</div><p>
<a class="anchor" name="6c9b1b9ec0b5095c80f01b302d7ae8fc"></a><!-- doxytag: member="scim::Pointer::get" ref="6c9b1b9ec0b5095c80f01b302d7ae8fc" args="() const" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="a00070.html">scim::Pointer</a>&lt; T &gt;::get           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the dumb pointer; the regular C pointer managed by the <a class="el" href="a00070.html">Pointer</a>. <dl class="return" compact><dt><b>Returns:</b></dt><dd>the dumb pointer. </dd></dl>

</div>
</div><p>
<a class="anchor" name="66c25e7cafa450953b2be771e54e9631"></a><!-- doxytag: member="scim::Pointer::null" ref="66c25e7cafa450953b2be771e54e9631" args="() const" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00070.html">scim::Pointer</a>&lt; T &gt;::null           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns true if the <a class="el" href="a00070.html">Pointer</a> has no dumb pointer. 
<p>

</div>
</div><p>
<a class="anchor" name="ad78f476defa6c49b73f2e273309038c"></a><!-- doxytag: member="scim::Pointer::release" ref="ad78f476defa6c49b73f2e273309038c" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="a00070.html">scim::Pointer</a>&lt; T &gt;::release           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Releases the dumb pointer. <dl class="return" compact><dt><b>Returns:</b></dt><dd>the regular C pointer previously managed by the <a class="el" href="a00070.html">Pointer</a>.</dd></dl>
<br>
Before releasing the dumb pointer its reference count is incremented to prevent it being destroyed. You must call unref() on the pointer to prevent a memory leak. 
</div>
</div><p>
<a class="anchor" name="e3a6ef3a74cece3307a949a9d8c8b59d"></a><!-- doxytag: member="scim::Pointer::reset" ref="e3a6ef3a74cece3307a949a9d8c8b59d" args="(T *object=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00070.html">scim::Pointer</a>&lt; T &gt;::reset           </td>
          <td>(</td>
          <td class="paramtype">T *&nbsp;</td>
          <td class="paramname"> <em>object</em> = <code>0</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets a new dumb pointer for the <a class="el" href="a00070.html">Pointer</a> to manage. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>object</em>&nbsp;</td><td>- the new dumb pointer.</td></tr>
  </table>
</dl>
<br>
Releases the current dumb pointer, if any, and assigns <em>object</em> to the <a class="el" href="a00070.html">Pointer</a>, incrementing its reference count. 
</div>
</div><p>
<hr><h2>Friends And Related Function Documentation</h2>
<a class="anchor" name="681b62e04f3b869c899a18089eb39cc3"></a><!-- doxytag: member="scim::Pointer::operator==" ref="681b62e04f3b869c899a18089eb39cc3" args="(const Pointer&lt; T1 &gt; &amp;t1, const Pointer&lt; T2 &gt; &amp;t2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename T1, typename T2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool operator==           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00070.html">Pointer</a>&lt; T1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00070.html">Pointer</a>&lt; T2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>t2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compares two Pointers. <dl class="return" compact><dt><b>Returns:</b></dt><dd><em>true</em> if both Pointers manage to same dumb pointer. </dd></dl>

</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="a00146.html">scim_pointer.h</a></ul>
<hr size="1"><address style="align: right;"><small>Generated on Thu Jun 28 14:12:41 2007 for scim by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.0 </small></address>
</body>
</html>
